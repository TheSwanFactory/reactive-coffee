<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="styles/9981d504.main.css" media="screen">
    <title>Infelicities - reactive.coffee</title>
  </head>
  <body>
    <header>
      <div class="overlay"></div>
      <div class="inner">
        <h1 class="smaller-title"><a href="/reactive-coffee/">reactive.coffee</a></h1>
        <nav class="top-nav">
          <div class="inner-inner"><a href="quickstart.html">Documentation</a><a href="support.html">Community/Support</a><a href="design.html">Rationale</a><a href="dev-setup.html">Development</a></div>
        </nav>
      </div>
    </header>
    <div id="content-wrapper">
      <div class="inner clearfix">
        <nav class="side-nav">
          <ul>
            <li><a href="dev-setup.html">Dev Setup</a></li>
            <li><a href="infelicities.html" class="current">Infelicities</a><ul class="toc"><li><a href="#lazy-change propagation">Lazy change propagation</a></li><li><a href="#structural-attribute bindings">Structural Attribute Bindings</a></li><li><a href="#topologically-ordered visits">Topologically Ordered Visits</a></li><li><a href="#garbage-collection">Garbage Collection</a></li><li><a href="#lazy-event notification">Lazy Event Notification</a></li><li><a href="#transitions">Transitions</a></li><li><a href="#dag-debugger">DAG Debugger</a></li><li><a href="#tests">Tests</a></li></ul></li>
            <li><a href="ideas.html">Ideas</a></li>
            <li><a href="https://github.com/yang/reactive-coffee">GitHub</a></li>
          </ul>
        </nav>
        <section id="main-content"><h1>Infelicities</h1>
<p>There are a number of areas for immediate improvement, including but not
limited to the following:</p>
<h2><a name="lazy-change propagation">Lazy change propagation</a></h2>
<p>This one is rather low-hanging fruit: when a cell&#39;s value has been set to the
same value, we should not propagate events downstream to dependent nodes.</p>
<h2><a name="structural-attribute bindings">Structural Attribute Bindings</a></h2>
<p>Currently, attributes are strings.  For most attributes this is fine, but for
certain attributes such as <code>style</code>, we could have a simple convenience
preprocessor that takes in an object map of the style names and renders the
string.  This could be extended to lists for <code>class</code> and so on.</p>
<h2><a name="topologically-ordered visits">Topologically Ordered Visits</a></h2>
<p>If we consider the DAG of dependencies among observable nodes, when there&#39;s an
event being propagated through the system, the notifications currently visit
nodes in depth-first order.  However, the most efficient order in which to
propagate changes is by processing the events of the nodes in topologically
sorted order.  For instance, consider the following DAG:</p>
<pre><code>A -&gt; B
A -&gt; C
B -&gt; D
C -&gt; D
D -&gt; E</code></pre>
<p><img src="images/9df74959.cell-dag.png" alt="DAG"></p>
<p>If <code>A</code> is updated, then we&#39;d currently perform a recursive descent starting at
<code>A</code> and visit the nodes in this order:</p>
<pre><code>A, B, D, E, C, D, E</code></pre>
<p>However, if we kept track of the DAG, then we could process the nodes in
topologically sorted order:</p>
<pre><code>A, B, C, D, E</code></pre>
<p>This guarantees avoiding multiple visits to the same node.</p>
<h2><a name="garbage-collection">Garbage Collection</a></h2>
<p>Dependencies hold references to their dependents in order to know who to
propagate updates to.  We do currently unsubscribe a dependent observable
from its dependencies whenever that dependent is refreshed, but if the
dependent observable itself creates nested binds, those nested binds may
not be cleaned up.</p>
<p>For instance, say we have:</p>
<div class="highlight"><pre><span class="nv">showUnread = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="nv">unread = </span><span class="nx">rx</span><span class="p">.</span><span class="nx">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;scoreboard&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="p">[</span>
  <span class="k">if</span> <span class="nx">showUnread</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span>
    <span class="nx">div</span> <span class="p">{</span><span class="k">class</span><span class="o">:</span> <span class="s">&#39;unread&#39;</span><span class="p">},</span> <span class="nx">bind</span> <span class="nf">-&gt;</span> <span class="s">&quot;</span><span class="si">#{</span><span class="nx">unread</span><span class="p">.</span><span class="nx">get</span><span class="p">()</span><span class="si">}</span><span class="s"> message(s)&quot;</span>
  <span class="k">else</span>
    <span class="s">&#39;(nothing shown)&#39;</span>
<span class="p">]</span>
</pre></div>

<p>Initially, <code>unread</code> has a subscriber, as expected: the inner <code>bind</code>.  When
we update <code>showUnread</code>, the outer <code>bind</code> will re-evaluate and create a new
inner <code>bind</code> (for the nested <code>div</code>), completely forgetting about the old
one.  However, now <code>unread</code> has <em>two</em> subscribers, old and new inner
<code>bind</code>s.  And since the old inner <code>bind</code> is still referenced from
<code>unread</code>&#39;s list of subscribers, it can&#39;t be garbage-collected.  Ergo,
memory leak.</p>
<p>What needs to happen: <code>bind</code> should track any nested <code>bind</code>s.  On
re-evaluation, these inner <code>bind</code>s should be <em>disposed</em> of, unsubscribing
themselves from all their dependencies (thus dependency tracking is a
pre-requisite).  This disposal should also occur recursively down to
<em>their</em> nested <code>bind</code>s, and so on.</p>
<h2><a name="lazy-event notification">Lazy Event Notification</a></h2>
<p>More flexible-but-still-efficient array (and other data structure) mutations.
Currently arrays have built-in mechanisms for efficient propagation of events
such as insertion, removal, splicing, etc.  However, for more involved
transformations, or if we want to reuse existing array transformation code, we
can still do better than re-evaluating all dependents downstream by figuring
out what has changed, and then propagating the diff&#39;s or operations (such as
reorderings) for more efficient downstream handling.</p>
<p>This can be extended to arbitrary object types/data structures beyond arrays
and should be configurable, with the ability to substitute in various change
detection or diffing algorithms.</p>
<h2><a name="transitions">Transitions</a></h2>
<p>Ability to apply animations and effects to things like entrances, exits, and
reorderings.  See the <a href="https://github.com/mbostock/d3/wiki/Transitions">d3 transitions API</a> for something I&#39;m keen on borrowing
from.</p>
<h2><a name="dag-debugger">DAG Debugger</a></h2>
<p>A facility to visualize the DAG of dependencies would make code debugging
and understanding easier.</p>
<h2><a name="tests">Tests</a></h2>
<p>And examples.  Need more tests and examples.  &#39;Nuff said.</p>

        </section>
      </div>
    </div><!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script type="text/javascript">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-41900480-1', 'yang.github.io');
      ga('send', 'pageview');
    </script>
    <footer>
      <div class="inner"><p>Copyright 2013 Reactive Coffee Authors.<br>Code licensed under <a href="https://github.com/yang/reactive-coffee/blob/master/LICENSE">MIT License</a>.  Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.<br>Website design based on Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>

      </div>
    </footer>
  </body>
</html>